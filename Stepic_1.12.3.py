"""
Напишите простой калькулятор, который считывает с пользовательского ввода три строки: первое число,
второе число и операцию, после чего применяет операцию к введённым числам
("первое число" "операция" "второе число") и выводит результат на экран.
Поддерживаемые операции: +, -, /, *, mod, pow, div, где
mod — это взятие остатка от деления,
pow — возведение в степень,
div — целочисленное деление.

Если выполняется деление и второе число равно 0, необходимо выводить строку "Деление на 0!".
Обратите внимание, что на вход программе приходят вещественные числа.

Sample Input 1:
5.0
0.0
mod
Sample Output 1:
Деление на 0!
Sample Input 2:
-12.0
-8.0
*
Sample Output 2:
96.0
Sample Input 3:
5.0
10.0
/
Sample Output 3:
0.5
"""

a, b, c = (input() for _ in range(3))
operations = {"mod": "%", "div": "//", "pow": "**"}
try:
	print(eval("(" + a + ")" + operations.get(c, c) + b))
except ZeroDivisionError:
	print('Деление на 0!')

"""
нельзя как-то заставить питон считать операцию инпута? на пример s = a + c + b, где "с" это  операция?" - 
да, можно (правда в предыдущих уроках почти ничего из этого не было)
Всё довольно просто - на вход мы получаем три значения, два числа и знак, и, если их в правильном порядке 
соединить друг с другом, получится вполне осмысленное выражение.
Для того, чтобы это выражение прочитать, есть функция eval(), принимающая на вход строку и преобразовывающая её 
в выражение, с которым интерпретатор может работать. Соответственно, нам необходимо все три значения привести к 
типу string* и объединить их в одну строку, что легко сделать при помощи конкатенации строк.

Если со знаками +, -, *, / всё просто, их интерпретатор воспримет как надо и выдаст корректный результат, т
о как быть с pow, div, mod, ведь таких действий питон не знает. Нужно им как-то задать соответствия и 
в этом помогает словарь. В словаре задаются пары ключ, значение. В моём решении это переменная operations. 
Получить значение по ключу можно несколькими способами, но, так как я в словаре указал всего три пары, 
мне был нужен тот, который избавит меня от лишней условной инструкции, указывающей интерпретатору что делать, 
если ключа нет в словаре. Это метод .get(). Он позволяет получить из словаря значение по ключу, так же в нём 
можно указать значение, которое будет возвращаться в случае отсутствия указанного ключа в словаре. Выглядит 
это следующим образом словарь.get("ключ", "значение, если ключа нет в словаре").

Осталось лишь обработать ситуацию, когда что-то делится на 0. Тут можно было бы использовать условную инструкцию, 
перечислить условия, когда выдавалось бы сообщение "Деление на 0!", но это было бы более громоздко и, на мой взгляд, 
менее читабельно. Потому я использовал try...except. Эта конструкция пробует выполнить действие указанное в блоке 
try и, если возникает ошибка, указанная в except (в нашем случае это ZeroDivisionError, тоесть деление на 0) 
действие программы не прерывается, а выполняется блок except, в нашем случае это печать сообщения "Деление на 0!".
"""